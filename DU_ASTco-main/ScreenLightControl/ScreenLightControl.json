{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"local Title = \"Title goes here\" --export: used only with Master_Unit \nlocal Hide_Unit = false --export\nlocal Refresh_Rate = 3 --export\nMaster_Unit = true --export: The board with control screen. Set to false on all other connected boards\n\n--------------------------------------------------------------\nlocal version = 0.42\nscreens, lights = {}, {}\n\nfor slot,element in pairs(unit)do -- checking elements in slots\n    if type(element)==\"table\"and type(element.export)==\"table\"then\n        if element.getClass then\n            if element.getClass()==\"ScreenUnit\" or element.getClass()==\"ScreenSignUnit\" then\n                screens[#screens+1]=element\n                screens[#screens].slot=slot\n                element.activate()\n            elseif element.getClass()==\"LightUnit\"then \n                lights[#lights+1]=element\n                element.activate()\n            elseif element.getClass()==\"DataBankUnit\" then\n                Databank = element\n            end \n        end \n    end \nend\n\nif not Databank then\n    system.print(\"ERROR: no databank found\")\n    unit.exit()\nelse\n    Databank.setStringValue(unit.getLocalId(),unit.getLocalId()..\",\"..#lights..\",\"..#screens)\n    if Databank.hasKey(\"RGB\") == 0 then \n        ScreenVar = \"local BackgroundColor = {r=0,g=0,b=0}\"\n        Databank.setStringValue(\"RGB\",json.encode({r=0,g=0,b=0}))\n    else\n        local DB = (json.decode(Databank.getStringValue('RGB')))\n        ScreenVar = [[local BackgroundColor = {r=]].. DB.r ..[[,g=]].. DB.g ..[[,b=]].. DB.b ..[[}]]\n    end\nend\n\nif Master_Unit then\n    table.sort(screens, function(a,b) return a.slot < b.slot end) -- sorting screens table by slot\n    ScreenVar = ScreenVar .. [[\n    local Title = \"]] .. Title ..[[\"\n    local Version = ]] .. version ..[[   \n    local BoardList = {}\n    ]] \n    screens[1].setRenderScript(ScreenVar .. ControlScreenContent) -- setting content of control screen\nend\n\nunit.setTimer(\"upd\",Refresh_Rate)\nif Hide_Unit then unit.hideWidget() end\n\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"if Master_Unit then\n    local ScreenRawOutput = screens[1].getScriptOutput() -- checking action from control screen\n    local ScreenOutput = json.decode(ScreenRawOutput)\n    if ScreenOutput then\n        if ScreenOutput then\n            for i=2, #screens do screens[i].setRenderScript(\"local color = {r=\"..ScreenOutput.r..\",g=\".. ScreenOutput.g..\",b=\".. ScreenOutput.b..\"}\"..ScreensContent) end\n            for key, light in pairs(lights) do light.setColor(ScreenOutput.r,ScreenOutput.g,ScreenOutput.b) end\n            screens[1].clearScriptOutput()\n        end\n        if Databank then Databank.setStringValue(\"RGB\",ScreenRawOutput) end\n    end\n\n    if not FirstRun then\n        local keys = Databank.getKeyList()-- getting linked items list\n        for i=1, #keys do \n            if keys[i] ~= 'RGB' then\n                ScreenVar = ScreenVar .. [[\n                BoardList[#BoardList+1] = \"]] .. Databank.getStringValue(keys[i]) .. [[\"\n                ]]\n            end\n        end\n        screens[1].setRenderScript(ScreenVar .. ControlScreenContent) -- setting content of control screen\n        FirstRun = true\n    end\nend\n    \n--else -- if not master_unit\n    if Databank then\n        local ScreenOutput = json.decode(Databank.getStringValue('RGB'))\n        if ScreenOutput then\n        if Master_Unit then j = 2 else j = 1 end\n            for i=j, #screens do screens[i].setRenderScript(\"local color = {r=\"..ScreenOutput.r..\",g=\".. ScreenOutput.g..\",b=\".. ScreenOutput.b..\"}\"..ScreensContent) end\n            for key, light in pairs(lights) do light.setColor(ScreenOutput.r,ScreenOutput.g,ScreenOutput.b) end\n        end\n    end\n--end","filter":{"args":[{"value":"upd"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"ControlScreenContent = [[\n\n\n\n\n\nlocal json = require(\"dkjson\")\nlocal small = loadFont('Play', 14)\nlocal font = loadFont('Play', 24)\n-- Get screen resolution\nlocal rx, ry = getResolution()\nlocal infoFont = loadFont('RobotoMono', 12)\nlocal medium = loadFont('Play', 20)\nlocal big = loadFont('Montserrat', 46)\nlocal layer = createLayer()\nlocal IconSize = 32\n\n\nsetNextTextAlign( layer, AlignH_Center, AlignV_Middle)\naddText( layer, big, Title, rx*0.28, ry*0.054)\n\nsetNextTextAlign( layer, AlignH_Right, AlignV_Middle)\naddText( layer, medium, \"Screens & Lights Control v\"..Version, rx*0.98, ry*0.03)\n\n----------------------------------------------------------\n------------------ FUNCTIONS -----------------------------\n----------------------------------------------------------\n\n\nfunction Split(s, delimiter)\n    result = {};\n    for match in (s..delimiter):gmatch(\"(.-)\"..delimiter) do\n        table.insert(result, match);\n    end\n    return result;\nend\n\n\n-- Include event library\nlocal event = require('utils/event')\n--local json = require('dkjson')\n\n--# Button class definition called only at the first frame\nif not Button then\n\n    -- getEllipsis( font, text, maxWidth)\n    -- Return a shorten text string by with with ... at the end\n    function getEllipsis(font, text, maxWidth)\n        local width = getTextBounds(font, '...')\n\n        for i = 1, #text do\n            local line = getTextBounds(font, text:sub(1,i)) + width\n            if line > maxWidth then\n                return text:sub(1,i-1)..'...'\n            end\n        end\n        return text\n    end\n\n\n    Button = {}\n    Button.__index = Button\n    -- Button object constructor\n    -- .x : X component of the position\n    -- .y : Y component of the position\n    -- .width : Width of the button\n    -- .height : Height of the button\n    -- .caption : Associated text caption\n    -- .onPressed = event:new() : Event triggered when the button is pressed\n    -- .onDown = event:new() : Event triggered when the button is hold down\n    -- .onReleased = event:new() : Event triggered when the button is released\n    -- .onHover = event:new() : Event triggered when the button is hovered\n    -- .onLeave = event:new() : Event triggered when the button is leave\n    function Button:new(x, y, width, height, caption)\n        local self = {\n            x = x or 0,\n            y = y or 0,\n            w = width or 100,\n            h = height or 20,\n            caption = caption or \"\",\n            onPressed = event:new(),\n            onDown = event:new(),\n            onReleased = event:new(),\n            onEnter = event:new(),\n            onLeave = event:new(),\n            clicked = false,\n            hover = false\n        }\n\n        --Handle button events\n        function self:compute(mx,my)\n            local x, y, w, h = self.x, self.y, self.w, self.h\n\n            if mx>x and mx<x+w and my>y and my<y+h then\n                if getCursorPressed() then\n                    self.onPressed:emit(self,mx,my)\n                    self.clicked = true\n                elseif getCursorReleased() then\n                    self.onReleased:emit(self,mx,my)\n                    self.clicked = false\n                elseif getCursorDown() then\n                    self.onDown:emit(self,mx,my)\n                    self.clicked = true\n                end\n\n                if not self.hover then\n                    self.onEnter:emit(self,mx,my)\n                    self.hover = true\n\n                end\n            elseif self.hover then\n                self.onLeave:emit(self,mx,my)\n                self.hover = false\n            end\n        end\n\n        -- Draws the button on the screen using the given layer\n        function self:draw(layer, font)\n            -- Localize object data\n            local x, y, w, h = self.x, self.y, self.w, self.h\n            local min, max = self.min, self.max\n\n            --# Draw the button\n            -- Define box default strokes style\n            setDefaultStrokeColor(layer, Shape_BoxRounded, 1, 1, 1, 1)\n            setDefaultStrokeWidth(layer, Shape_BoxRounded, 0.1)\n\n            -- If the button is clicked change the background\n            if self.clicked then\n                setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            elseif self.hover then\n                setNextFillColor(layer, 0.3, 0.3, 0.3, 1)\n            else\n                setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            end\n            addBoxRounded(layer, x, y, w, h, 4)\n\n            -- Draw caption and value display          \n            local caption = getEllipsis(font, self.caption, w-12)\n            local font = font or nil\n\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, caption, x+0.5*w, y+0.5*h)\n        end\n\n\n        return setmetatable(self, Button)\n    end\n\nend\n\n\nlocal mx, my = getCursor()\n\n\n\n\n\n\n\n\n\n\n\n\n--# Slider class definition called only at the first frame\nif not Slider then\n\n\n    Slider = {}\n    Slider.__index = Slider\n    -- Slider object constructor\n    -- .x : X component of the position\n    -- .y : Y component of the position\n    -- .width : Width of the slider\n    -- .length : Lenght of the slider\n    -- .min : Minimum value\n    -- .max : Maximum value\n    -- .label : Associated text label\n    function Slider:new(x, y, width, length, min, max, value, label)\n        local self = {\n            x = x or 0,\n            y = y or 0,\n            l = length or 100,\n            w = width or 20,\n            min = min or 0,\n            max = max or 5,\n            ratio = 0,\n            label = label or \"\",\n            drag = false,\n            color = {1,1,1}\n        }\n        self.ratio = math.max(0, math.min(1, (value or self.min)/(self.max-self.min)))\n\n\n\n        -- Set the value of the slider\n        function self:setValue(val)\n            if type(val) == 'number' then\n                self.value = math.max(self.min, math.min(self.max, val))\n            end\n        end\n\n        -- Get the value of the slider\n        function self:getValue(val)\n            return self.ratio*(self.max - self.min) + self.min\n        end\n\n        -- Draws the slider on the screen using the given layer\n        function self:draw(layer)\n\n\n\n\n\n            -- Localize object data\n            local x, y, w, l = self.x, self.y, self.w, self.l\n            local min, max, ratio = self.min, self.max\n\n\n            -- Get cursor data (position and button state)\n            local mx, my = getCursor()\n            local pressed = getCursorPressed()\n            local released = getCursorReleased()\n\n            -- Determine if the cursor is on the bar and detect if the mouse is down\n            if (mx >= x and mx <= x+w) and (my >= y and my <= y+l) then\n\n                if pressed then self.drag = true end\n            end\n\n            -- Set the ratio based on the cursor position\n            if self.drag then\n                self.ratio = math.max(0, math.min(1, 1 - (my-y)/l))\n                if released then\n                    self.drag = false\n                end\n            end\n\n            -- Compute the slider ratio\n            local ratio = self.ratio\n            local h = ratio*(max-min)\n            local color = self.color\n            if h > 1 then \n                setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n                addText( layer, font, \"HDR\", x+0.5*w, y+l+50) \n            end\n\n            --# Draw the slider\n            -- Define box default strokes style\n            setDefaultStrokeColor(layer, Shape_BoxRounded, 1, 1, 1, 1)\n            setDefaultStrokeWidth(layer, Shape_BoxRounded, 0.1)\n\n            -- Draw the back box\n            setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            addBoxRounded(layer, x, y, w, l, 0)\n\n            -- Draw the fill box\n            setNextFillColor(layer, color[1], color[2], color[3], 1)\n            addBoxRounded(layer, x, y+(1-ratio)*l, w, l*ratio, 0)\n\n            -- Draw the handle\n            setNextFillColor(layer, 0.5, 0.5, 0.5, 1)\n            addBoxRounded(layer, x-3, y+(1-ratio)*l -3, w+6, 6, 0)\n\n\n            -- Draw label and value display\n            --local label = self.label\n            --setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            --addText( layer, font, label, x+0.5*w, y-14)\n\n            local display = string.format('%.2f', ratio*(max - min) + min)\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, display, x+0.5*w, y+l+18)\n        end\n\n\n        return setmetatable(self, Slider)\n    end\n\nend\n\n--------------------------------------------------------------\n------------------ INIT -----------------------------\n--------------------------------------------------------------\n\n--# Initialization called only at the first frame\nif not _init then\n    local r, g, b = BackgroundColor.r, BackgroundColor.g, BackgroundColor.b\n\n    -- Create three sliders and set their color\n    sliderRed = Slider:new(rx*0.6, ry*0.15, 80, ry*0.64, 0, 5, r, \"Red\")\n    sliderRed.color = { 1, 0, 0}\n\n    sliderGreen = Slider:new(rx*0.72, ry*0.15, 80, ry*0.64, 0, 5, g, \"Green\")\n    sliderGreen.color = { 0, 1, 0}\n\n    sliderBlue = Slider:new(rx*0.84, ry*0.15, 80, ry*0.64, 0, 5, b, \"Blue\")\n    sliderBlue.color = { 0, 0, 1}\n\n\n\n\n\n\n\n\n    -- Draw the SET buttons\n    _button_setLights = Button:new(rx*0.05+rx*0.225-100, 0.54*ry, 200, 58, \"Set Color\")\n\n    --Add the action on the actions event.\n    --event:addAction( call, enabled, limit)\n\n\n    _button_setLights.onReleased:addAction( function(self,x,y)\n            setOutput(json.encode(\n                    {\n                            [\"r\"] = sliderRed:getValue(),\n                            [\"g\"] = sliderGreen:getValue(),\n                            [\"b\"] = sliderBlue:getValue()})\n            )\n        end, true)\n\n\n    _init = true\nend\n\n\n--------------------------------------------------------------\n--------------------------------------------------------------\n\n\n\nlocal imagelayer = createLayer()\n\n\n\n\n\n\nlocal x = rx*0.05\nlocal y = ry*0.05\nlocal textlayer = createLayer()\n\nlocal BoardImage = loadImage(\"resources_generated/elements/programming-boards/programming-board_001/icons/env_programming-board_001_icon.png\")\nlocal ScreenImage = loadImage(\"resources_generated/elements/screens/screen-trans_001/icons/env_screen-trans_001_icon.png\")\nlocal LightImage = loadImage(\"resources_generated/elements/lights/light-vertical_001_xs/icons/env_light-vertical_001_xs_icon.png\")\n\nfor i=1, #BoardList do\n\n    if (i % 2 == 0) then\n    --if i > 5 then\n     --y = ry*0.11 -- reset y\n       x =  rx*0.3-- set x for second column\n        \n        else\n        x = rx*0.05\n        y = y + ry*0.08\n    end\n    --if i == 6 then x = rx*0.08 end\n    \n    \n    \n    \n\n    setNextFillColor( layer, 0.05, 0.05, 0.05, 0.8)\n    addBox( layer, x, y, rx*0.2, ry*0.06)\n\n    addImage(imagelayer, BoardImage, x,y-IconSize*0.6, IconSize*2.4, IconSize*2.4)\n    setNextTextAlign( textlayer, AlignH_Center, AlignV_Top)\n    addText( textlayer, small, \"[\"..Split(BoardList[i], \",\")[1]..\"]\", x+IconSize*1.2, y)\n\n    \n    setNextTextAlign( textlayer, AlignH_Center, AlignV_Middle)\n    addText( textlayer, font, Split(BoardList[i], \",\")[2], x+100, y+20)\n    addImage(imagelayer, ScreenImage, x+110,y+3, IconSize, IconSize)\n\n    \n    setNextTextAlign( textlayer, AlignH_Center, AlignV_Middle)\n    addText( textlayer, font, Split(BoardList[i], \",\")[3], x+168, y+20)\n    addImage(imagelayer, LightImage, x+170,y+3, IconSize, IconSize)\n    -- image = loadImage(line)\n    \n\nend\n\n-- Draw buttons\n_button_setLights:compute(mx,my)\n_button_setLights:draw( layer, medium)\n\n\n\n\n\n\n\n\n\n-- Draw a box behind the sliders\nsetNextFillColor( layer, 0.05, 0.05, 0.05, 1)\naddBoxRounded( layer, rx*0.55, ry*0.11, rx*0.415, ry*0.85, 16)\n\n\n-- Draw sliders\nsliderRed:draw( layer)\nsliderGreen:draw( layer)\nsliderBlue:draw( layer)\n\n\n\n--# Rendering\n-- Set the background color based on sliders value\n-- Box background\nsetNextFillColor( layer, sliderRed:getValue(),  sliderGreen:getValue(), sliderBlue:getValue(), 1)\naddBoxRounded( layer, rx*0.05, ry*0.66, rx*0.45, ry*0.3, 16)\n\n\n\n-- Request a run at each frame\nrequestAnimationFrame(1)\n\n\n\n\n]]","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"2"},{"code":"ScreensContent = [[\n\n\nlocal json = require(\"dkjson\")\nlocal layer = createLayer()\nlocal rx,ry=getResolution() \n\nfor i=0, 1, 0.03 do\n    setNextStrokeColor(layer,0, 0, 0,1)\n    addLine(layer,0,ry*i,rx,ry*i)\nend\n\n\n    setBackgroundColor(color.r, color.g, color.b)\n--setOutput(json.encode(color))\n\n]]","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"3"}],"methods":[],"events":[]}
